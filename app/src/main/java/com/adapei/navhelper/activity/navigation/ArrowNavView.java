package com.adapei.navhelper.activity.navigation;

import static com.adapei.navhelper.Constants.DEGREE_ARROW;
import static com.adapei.navhelper.Constants.MAPBOX_ACCESS_TOKEN;
import static com.adapei.navhelper.Constants.locationEngine;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.hardware.Sensor;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.location.Location;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.Vibrator;
import android.speech.tts.TextToSpeech;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.text.TextUtils;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.adapei.navhelper.Checkpoint;
import com.adapei.navhelper.CheckpointAdapterArrow;
import com.adapei.navhelper.Constants;
import com.adapei.navhelper.Destination;
import com.adapei.navhelper.ManeuverMap;
import com.adapei.navhelper.R;
import com.adapei.navhelper.activity.ArrowNavCheckpointAddView;
import com.adapei.navhelper.activity.ArrowNavCheckpointManagementView;
import com.adapei.navhelper.database.CheckPointData;
import com.adapei.navhelper.database.PhoneData;
import com.adapei.navhelper.listener.MyMilestoneEventListener;
import com.adapei.navhelper.listener.MyOffRouteListener;
import com.adapei.navhelper.listener.MyProgressChangeListener;
import com.adapei.navhelper.listener.MySensorEventListener;
import com.mapbox.api.directions.v5.DirectionsCriteria;
import com.mapbox.api.directions.v5.models.DirectionsResponse;
import com.mapbox.api.directions.v5.models.DirectionsRoute;
import com.mapbox.api.directions.v5.models.LegStep;
import com.mapbox.api.directions.v5.models.RouteLeg;
import com.mapbox.api.directions.v5.models.StepIntersection;
import com.mapbox.api.directions.v5.models.StepManeuver;
import com.mapbox.geojson.Point;
import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigation;
import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute;
import com.mapbox.services.android.navigation.v5.routeprogress.RouteLegProgress;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Objects;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import timber.log.Timber;

/**
 * Class for the navigation with an arrow
 */
public class ArrowNavView extends NavView {

    /**
     * to keep last update of the arrow
     */
    private Date lastUpdate;

    /**
     * Mapbox navigation session
     */
    private MapboxNavigation navigation;

    /**
     * Destination of the session
     */
    private Destination destination;

    /**
     * Manager for the sensors
     */
    private SensorManager mSensorManager;

    /**
     * Arrow rotating showing the good direction
     */
    private ImageView arrow;

    /**
     * Text panel showing the next step
     */
    private TextView nextStepTextView;

    /**
     * Image showing the next step
     */
    private ImageView nextStepImageView;

    /**
     * Text indicating the remaining distance to the next step point
     */
    private TextView nextStepDistanceRemainTextView;

    /**
     * List of the settled checkpoints of the route
     */
    private List<Checkpoint> checkpoints;

    /**
     * Point representing the next direction
     */
    private Point nextDirection; // in degrees

    /**
     * Progression on the current leg
     */
    private RouteLegProgress currentLegProgress;

    /**
     * The text to speech instance
     */
    private TextToSpeech textToSpeech;

    /**
     * Previous instruction displayed
     */
    private String lastInstruction;

    /**
     * True if sensor are bound
     */
    private boolean haveSensor;

    /**
     * True if the current orientation is in the good direction
     */
    private boolean okPosition = false;

    /**
     * Listener for sensor events
     */
    private SensorEventListener myEventSensorListener;

    /**
     * Lock for the standby mode
     */
    private PowerManager.WakeLock wakelock;

    /**
     * User preferences
     */
    private SharedPreferences sharedPreferences;

    /**
     * route checkpoints generated by MapBox
     */
    private List<Point> intersections;

    /**
     * list of checkpoints that the user is close to
     */
    private ArrayList<Checkpoint> markedCP;

    private Calendar currentTime;
    private CheckpointAdapterArrow adapter;
    private RecyclerView recyclerView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_arrow_nav_view);

        Bundle extras = getIntent().getExtras();

        this.lastUpdate = new Date();

        this.destination = Constants.GSON.fromJson(extras.getString(getResources().getString(R.string.DestinationHomeToNav)), Destination.class);
        this.sharedPreferences = this.getSharedPreferences(getResources().getString(R.string.sharedPreferencesKey), MODE_PRIVATE);
        this.mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); // Compass

        this.textToSpeech = new TextToSpeech(this, new TextToSpeech.OnInitListener() {
            @Override
            public void onInit(int status) {
                if(status != TextToSpeech.ERROR) {
                    textToSpeech.setLanguage(Locale.FRANCE);
                }
            }
        });

        nextStepDistanceRemainTextView = findViewById(R.id.distanceText);
        nextStepImageView = findViewById(R.id.maneuverImage);
        nextStepTextView = findViewById(R.id.maneuverText);
        arrow = findViewById(R.id.greenArrow);

        recyclerView = findViewById(R.id.arrowRecycler);
        recyclerView.setHasFixedSize(true);

        LinearLayoutManager manager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);
        this.recyclerView.setLayoutManager(manager);

        // Standby mode deactivated
        PowerManager pm = (PowerManager) this.getSystemService(Context.POWER_SERVICE);
        wakelock = pm != null ? pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK
                | PowerManager.ON_AFTER_RELEASE, this.getClass().getName()) : null;

        boolean profile = this.sharedPreferences.getBoolean(getResources().getString(R.string.profilePreferencesName), true);

        if (profile) { // if profile is set to "accompagnateur"
            findViewById(R.id.cameraButton).setVisibility(View.VISIBLE);
            findViewById(R.id.fileButton).setVisibility(View.VISIBLE);
        } else {
            findViewById(R.id.cameraButton).setVisibility(View.GONE);
            findViewById(R.id.fileButton).setVisibility(View.GONE);
        }

        intersections = new ArrayList<>();
        if(locationEngine == null) Constants.initLocationEngine(this);

        initMapboxNavigation();
    }

    @Override
    protected void onStart() {
        super.onStart();
        if (wakelock != null) wakelock.acquire(10*60*1000L /*10 minutes*/);
    }

    /**
     * reactivate all sensors and get the location of the user then set the route once again
     */
    @Override
    protected void onResume() {
        super.onResume();

        myEventSensorListener = new MySensorEventListener(this);
        bindSensors();

        com.adapei.navhelper.Location.checkLocationPermission(this);
        //last location of the user
        Location lastLocation = Constants.locationEngine.getLastLocation();

        if (lastLocation == null) {
            //try 60 times every seconds to get the last user location, else it's not callable
            int nb = 60;

            while(nb > 0 && Constants.locationEngine.getLastLocation() == null) {
                nb--;
                try {
                    Thread.sleep(100);
                } catch(InterruptedException e) {
                    e.printStackTrace();
                }
            }

            if (nb == 0) locationEngineNotCallable();
        } else {
            this.setRoute(Point.fromLngLat(lastLocation.getLongitude(), lastLocation.getLatitude()), destination.toPoint());
        }
    }

    /**
     * Alert when the location engine is not callable
     */
    private void locationEngineNotCallable() { System.out.println("locationEngineNotCallable : Error, the location engine is not callable"); }

    //these functions are explicit. Depends on the state of the app do action.

    @Override
    protected void onPause() {
        super.onPause();
        unbindSensors();
    }

    @Override
    protected void onStop() {
        super.onStop();
    }

    @Override
    protected void onDestroy() {
        // when the view is closed we need to close everything and close what we used*
        this.navigation.endNavigation();
        this.navigation.onDestroy();
        Constants.initLocationEngine(this);

        if(this.textToSpeech != null) {
            this.textToSpeech.stop();
            this.textToSpeech.shutdown();
        }

        if (this.wakelock != null) this.wakelock.release();

        super.onDestroy();
    }

    /**
     * Initialise the Mapbox navigation
     */
    private void initMapboxNavigation() {
        try {
            //the part where the navigation really starts
            navigation = new MapboxNavigation(this, MAPBOX_ACCESS_TOKEN);
            navigation.addProgressChangeListener(new MyProgressChangeListener(this));
            navigation.addMilestoneEventListener(new MyMilestoneEventListener(this));
            navigation.addOffRouteListener(new MyOffRouteListener(this));
        } catch (Exception e) {
            System.err.println("initMapboxNavigation : " + e.getMessage());
        }
    }

    /**
     * Set the route for the navigation,that we use to start the navigation + parameters
     * @param origin Starting point of the route
     * @param destination Ending point of the route
     */
    private void setRoute(Point origin, Point destination) {

        try {
            // This part is a copy of setRoute from MapNavView
            NavigationRoute.builder(this)
                    .accessToken(MAPBOX_ACCESS_TOKEN)
                    .origin(origin)
                    .destination(destination)
                    .profile(this.sharedPreferences.getString(getResources().getString(R.string.favoriteTypePreferencesName), DirectionsCriteria.PROFILE_WALKING))
                    .language(Locale.FRENCH)
                    .voiceUnits(DirectionsCriteria.METRIC)
                    .build()
                    .getRoute(new Callback<DirectionsResponse>() {
                        @Override
                        public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) {
                            // You can get the generic HTTP info about the response
                            Timber.d("Response code: %s", response.code());

                            if (response.body() == null) {
                                Timber.e("No routes found, make sure you set the right user and access token.");
                                finish();
                            } else if (response.body().routes().size() < 1) {
                                Timber.e("No routes found");
                                finish();
                            } else {
                                initRoute(response.body().routes());
                            }
                        }

                        @Override
                        public void onFailure(Call<DirectionsResponse> call, Throwable throwable) {

                            System.err.println(throwable.getMessage());
                            finish();
                        }
                    });
        } catch (Exception e) {
            System.err.println("setRoute : " + e);
        }
    }

    /**
     * Initialize the route by choosing the one with the most checkpoints
     * @param routes List containing the routes
     */
    private void initRoute(List<DirectionsRoute> routes) {
        DirectionsRoute bestRoute = null;
        List<Checkpoint> checkpointsBestRoute = null;

        // look for the best route
        for (DirectionsRoute route : routes) {
            List<Checkpoint> checkpointsRoute = getCheckpointsForRoute(route);

            if (bestRoute == null || checkpointsBestRoute.size() < checkpointsRoute.size()) {
                bestRoute = route;
                checkpointsBestRoute = checkpointsRoute;
            }
        }

        try {
            if(bestRoute != null && bestRoute.legs() != null) {
                // We get all the intersection points to create the perfect route
                for(RouteLeg routeLeg : bestRoute.legs()) {
                    for(LegStep legStep : Objects.requireNonNull(routeLeg.steps())) {
                        if(legStep.intersections() != null && !legStep.intersections().isEmpty()) {
                            for(StepIntersection intersection : legStep.intersections()) intersections.add(intersection.location());
                        }
                    }
                }

                // We are removing all the points nearer than NEAR_POINT_METER except intersection points
                com.adapei.navhelper.Location.checkLocationPermission(this);
                Location currentPosition = Constants.locationEngine.getLastLocation();
                Point nextPoint = this.directionsRouteToPoints(bestRoute).get(0);

                for(int i = 0; i < 100 && currentPosition == null; i++){
                    currentPosition = Constants.locationEngine.getLastLocation();
                }

                if(!intersections.contains(nextPoint)) {
                    double distance = distanceInKmBetweenEarthCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(), nextPoint.latitude(), nextPoint.longitude());

                    while(bestRoute.legs().size() > 1 && distance < (Constants.NEAR_POINT_METER / 1000)) {
                        bestRoute.legs().remove(0);
                        distance = distanceInKmBetweenEarthCoordinates(currentPosition.getLatitude(),currentPosition.getLongitude(),this.directionsRouteToPoints(bestRoute).get(0).latitude(),this.directionsRouteToPoints(bestRoute).get(0).longitude());
                    }
                }
            }
        } catch(Exception e) {
            System.out.println(e.toString());
        }

        navigation.setLocationEngine(Constants.locationEngine);
        if(bestRoute != null) {
            navigation.startNavigation(bestRoute);
            List<Point> points = this.directionsRouteToPoints(bestRoute);
            this.nextDirection = points.get(0);
        }

        this.initCheckpoints(checkpointsBestRoute);
    }

    /**
     * Convert a value in degrees to radians
     * @param degrees value in degrees
     * @return value converted in radians
     */
    private double degreesToRadians(double degrees) { return degrees * Math.PI / 180; }

    /**
     * Calculate the distance in kms between to Earth coordinates
     * @param lat1 Latitude of the firt point
     * @param lon1 Longitude of the first point
     * @param lat2 Latitude of the second point
     * @param lon2 Longitude of the second point
     * @return The distance in kilometers between the two points
     */
    private double distanceInKmBetweenEarthCoordinates(double lat1, double lon1, double lat2, double lon2) {

        double dLat = degreesToRadians(lat2-lat1);
        double dLon = degreesToRadians(lon2-lon1);

        lat1 = degreesToRadians(lat1);
        lat2 = degreesToRadians(lat2);

        double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return Constants.EARTH_RADIUS * c;
    }

    /**
     * Initialize the checkpoints and all the list related to checkpoints
     * @param checkpointsBestRoute List containing checkpoints of the route
     */
    private void initCheckpoints(List<Checkpoint> checkpointsBestRoute) {
        this.checkpoints = checkpointsBestRoute;
        this.markedCP = new ArrayList<>(this.checkpoints.size());
        List<Point> points = new ArrayList<>();

        // sort the array of checkpoint from the closest to the farest
        Collections.sort(this.checkpoints, new Comparator<Checkpoint>() {
            @Override
            public int compare(Checkpoint checkpoint, Checkpoint t1) {

                int comp = 1;
                com.adapei.navhelper.Location.checkLocationPermission(ArrowNavView.this);
                Location loc = Constants.locationEngine.getLastLocation();

                for(int i = 0; i < 100 && loc == null; i++){
                    loc = Constants.locationEngine.getLastLocation();
                }

                com.adapei.navhelper.Location userLoc = new com.adapei.navhelper.Location(loc.getLatitude(), loc.getLongitude(), "UserLocalisation", "Localisation de lutilisateur");

                if(com.adapei.navhelper.Location.getDistanceBetweenCoordinates(userLoc, checkpoint) < com.adapei.navhelper.Location.getDistanceBetweenCoordinates(userLoc, t1)) comp = -1;

                return comp;
            }
        });

        //add all of the checkpoints detected on the route
        for (Checkpoint checkpoint : this.checkpoints) {
            points.add(checkpoint.toPoint());
        }
        this.adapter = new CheckpointAdapterArrow(this, this.checkpoints);
        //on click on one og the checkpoint, pronunciation of it's name and update the list.
        adapter.setOnItemClickListener(new CheckpointAdapterArrow.OnItemClickListener() {
            @Override
            public void onItemClickListener(View view, Checkpoint checkpoint) {
                textToSpeech.speak(checkpoint.getPronunciation(), TextToSpeech.QUEUE_FLUSH, null, null);
                updateCheckpoints();
            }
        });
        this.recyclerView.setAdapter(adapter);

        this.updateCheckpoints();
    }

    /**
     * Select the right image for this step
     * @param step the step to display
     * @return the right image id
     */
    private static int obtainManeuverResource(LegStep step) {
        // get the arrow corresponding to the instruction
        ManeuverMap maneuverMap = new ManeuverMap();
        if (step != null) {
            StepManeuver maneuver = step.maneuver();
            if (!TextUtils.isEmpty(maneuver.modifier())) {
                return maneuverMap.getManeuverResource(maneuver.type() + maneuver.modifier());
            } else {
                return maneuverMap.getManeuverResource(maneuver.type());
            }
        }
        return R.drawable.maneuver_starting;
    }

    /**
     * Check if sensors exists and bind them to the application
     */
    public void bindSensors() {
        if (mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR) == null) {
            if ((mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) == null) || (mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) == null)) {
                noSensorsAlert();
            } else {
                Sensor mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
                Sensor mMagnetometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
                haveSensor = mSensorManager.registerListener(myEventSensorListener, mAccelerometer, SensorManager.SENSOR_DELAY_FASTEST);
                mSensorManager.registerListener(myEventSensorListener, mMagnetometer, SensorManager.SENSOR_DELAY_FASTEST);
            }
        } else {
            Sensor mRotationV = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
            haveSensor = mSensorManager.registerListener(myEventSensorListener, mRotationV, SensorManager.SENSOR_DELAY_FASTEST);
        }
    }

    /**
     * Unbind all sensors
     */
    public void unbindSensors() {
        if (haveSensor) {
            Sensor mRotationV = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
            mSensorManager.unregisterListener(myEventSensorListener, mRotationV);
        } else {
            Sensor mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            Sensor mMagnetometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
            mSensorManager.unregisterListener(myEventSensorListener, mAccelerometer);
            mSensorManager.unregisterListener(myEventSensorListener, mMagnetometer);
        }
    }

    /**
     * Update the UI
     */
    public void updateUI() {
        this.updateNextStep();
        this.updateCheckpoints();
    }

    /**
     * Delete passed checkpoints and highlight incoming checkpoints
     */
    private void updateCheckpoints() {
        if (!checkpoints.isEmpty()) {

            com.adapei.navhelper.Location.checkLocationPermission(this);
            int numCheckpoint = 0;

            Location lastLoc = Constants.locationEngine.getLastLocation();
            for(int i = 0; i < 100 && lastLoc == null; i++){
                lastLoc = Constants.locationEngine.getLastLocation();
            }

            // Delete already passed marked checkpoints
            while (!checkpoints.isEmpty() && !this.markedCP.isEmpty() && this.markedCP.contains(this.checkpoints.get(numCheckpoint)) && !checkpoints.get(numCheckpoint).isNear(lastLoc)) {
                this.checkpoints.get(numCheckpoint).isMarked = false;
                checkpoints.remove(numCheckpoint);
                this.markedCP.remove(numCheckpoint);
                numCheckpoint++;
            }

            // pass already marked element
            while(numCheckpoint < checkpoints.size() && !this.markedCP.isEmpty() && this.markedCP.contains(this.checkpoints.get(numCheckpoint))) numCheckpoint++;

            // Mark near checkpoints
            while(numCheckpoint < checkpoints.size() && checkpoints.get(numCheckpoint).isNear(lastLoc)) {
                this.markedCP.add(this.checkpoints.get(numCheckpoint));
                this.checkpoints.get(numCheckpoint).isMarked = true;
                numCheckpoint++;
            }
            this.adapter.notifyDataSetChanged();
        }
    }

    /**
     * Update the information to the next step
     */
    private void updateNextStep() {

        // Update step distance remain text
        int distance = (int) Math.round(this.currentLegProgress.currentStepProgress().distanceRemaining());
        String text = String.format(getString(R.string.nextStepDistanceRemainTextFormat), String.format(getString(R.string.metterFormat), distance));
        this.nextStepDistanceRemainTextView.setText(text);

        LegStep upComingStep = this.currentLegProgress.upComingStep();
        if (upComingStep != null) {

            upComingStep.maneuver();
            // Update step picture
            this.nextStepImageView.setImageResource(obtainManeuverResource(upComingStep));

            // Update step text
            if (!TextUtils.isEmpty(upComingStep.name())) {
                //get the street name of the next instruction
                this.nextStepTextView.setText(upComingStep.name());
            } else if (!TextUtils.isEmpty(upComingStep.maneuver().instruction())) {
                // ... or just put the instruction itself instead
                this.nextStepTextView.setText(upComingStep.maneuver().instruction());
            }
        }
    }

    /**
     * Alert when there is no sensors
     */
    private void noSensorsAlert() { Toast.makeText(this, R.string.sensorProblem,Toast.LENGTH_LONG).show(); }

    /**
     * Set the next direction
     * @param nextDirection The new direction to set
     */
    public void setNextDestination(Point nextDirection) {
        this.nextDirection = nextDirection;
    }

    /**
     * Set the next direction by creating a average point between two given points
     * @param point1 First point for the average
     * @param point2 Second point for the average
     */
    public void setNextDestination(Point point1, Point point2) {
        // Get the average point between the 2 points
        double lat = (point1.latitude() + point2.latitude()) / 2.0;
        double lng = (point1.longitude() + point2.longitude()) / 2.0;
        this.nextDirection = Point.fromLngLat(lng,lat);
    }

    /**
     * Set the current leg progress
     * @param currentLegProgress The current leg progress to be set
     */
    public void setCurrentLegProgress(RouteLegProgress currentLegProgress) { this.currentLegProgress = currentLegProgress; }

    /**
     * Quit the view when the abort button is pressed
     * @param view
     */
    public void abortButtonClicked(View view)
    {
        this.finish();
    }

    /**
     * Pronounce the previous instruction
     * @param view The related view
     */
    public void repeatButtonClicked(View view) { this.textToSpeech.speak(this.getLastInstruction(), TextToSpeech.QUEUE_FLUSH, null, null); }

    /**
     * Get the previous instruction
     * @return The previous instruction
     */
    private String getLastInstruction() {
        return this.lastInstruction;
    }

    /**
     * Launch the emergency program
     * @param view The related view
     */
    public void SOSButtonClicked(View view) {
        final int DELAY = 10;

        Calendar cur = Calendar.getInstance();
        PhoneData phone = new PhoneData(this);
        cur.setTime(Calendar.getInstance().getTime());
        if(this.currentTime == null) {
            this.currentTime = cur;
        }

        String phoneNumber = this.sharedPreferences.getString(getResources().getString(R.string.phoneNumber), null);
        String phoneName = phone.getPhoneFromNumber(phoneNumber).getName();
        if (phoneNumber == null || phoneNumber.equals("0000000000")) {
            alertPhoneNumberNullWhenSOSNeeded();
        } else {
            com.adapei.navhelper.Location.checkLocationPermission(this);
            Location position = Constants.locationEngine.getLastLocation();
            if (position == null) {
                this.alertNoPositionWhenSOSNeeded();
            } else if(cur.compareTo(this.currentTime) >= 0) {
                this.currentTime = cur;
                this.currentTime.add(Calendar.SECOND, DELAY);
                String latLng = position.getLatitude() + "," + position.getLongitude();
                String message = getString(R.string.sosString) + latLng + ". " + getString(R.string.mapsURL) + latLng;
                sendSMS(phoneNumber,message);
                if(!phoneName.equals("")) {
                    Toast.makeText(this, "SMS envoyé à " + phoneName,Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(this, "SMS envoyé à " + phoneNumber,Toast.LENGTH_SHORT).show();
                }
            }
        }
    }

    /**
     * Update the navigation instructions
     * @param instruction Instructions to be displayed
     */
    public void updateInstruction(String instruction) {
        instruction = transformInstruction(instruction);

        this.lastInstruction = instruction;

        Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        v.vibrate(700);

        textToSpeech.speak(instruction, TextToSpeech.QUEUE_FLUSH, null, null);
    }

    /**
     * Rename some text (in english) by another (in french)
     * @param instruction instructions
     * @return the text renamed
     */
    private String transformInstruction(String instruction) {
        // to edit the instructions accordingly, you might need to change it if you update
        instruction = instruction.replaceAll(" miles", "mètres");
        instruction = instruction.replaceAll(" pieds", "mètres");
        instruction = instruction.replaceAll(" vers le sud-ouest", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers le sud-est", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers le nord-ouest", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers le nord-est", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers le sud", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers l'est", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers le nord", " vers le sens de la flèche, lorsqu'elle est verte, ");
        instruction = instruction.replaceAll(" vers l'ouest", " vers le sens de la flèche, lorsqu'elle est verte, ");
        return instruction;
    }

    /**
     * Launch the ArrowNavCheckpointManagementView activity
     * @param view The related view
     */
    public void checkpointsFolderButtonClicked(View view) {
        CheckPointData cp = new CheckPointData(this);

        if(cp.getNbCheckpoint() < 1) { //Checks that the user has at least 1 checkpoint
            Toast.makeText(getApplicationContext(), R.string.zeroCheckpointToDisplay, Toast.LENGTH_SHORT).show();
        } else { //If the number of checkpoints is greater than 0, launches the checkpoint management menu
            Intent arrowNavCheckpointManagementIntent = new Intent(this.getApplicationContext(), ArrowNavCheckpointManagementView.class);
            this.startActivity(arrowNavCheckpointManagementIntent);
        }
    }

    /**
     * Launch the ArrowNavCheckpointAddView activity
     * @param view The related view
     */
    public void checkpointAddButtonClicked(View view) {
        Intent arrowNavCheckpointPictureIntent = new Intent(this.getApplicationContext(), ArrowNavCheckpointAddView.class);
        this.startActivity(arrowNavCheckpointPictureIntent);
    }

    /**
     * Manage the route and alert if the user is off the route
     * @param location Location of the user
     */
    public void offRoute(Location location) {
        alertOffRoute(location);
        com.adapei.navhelper.Location.checkLocationPermission(this);
        setRoute(Point.fromLngLat(Constants.locationEngine.getLastLocation().getLongitude(), Constants.locationEngine.getLastLocation().getLatitude()), destination.toPoint());
    }

    /**
     * Alert if the user is off the route
     * @param location Location of the user
     */
    private void alertOffRoute(Location location) { textToSpeech.speak(getString(R.string.offRouteSpeech), TextToSpeech.QUEUE_FLUSH, null, null); }

    /**
     * Update the rotation of the arrow
     * @param rMat Rotational matrix
     */
    public void updateRotation(float[] rMat) {
        if (this.nextDirection == null) return;

        Date newUpdate = new Date();
        //Vérification de la date de la précédente mise à jour de la flèche
        if(newUpdate.getTime() - this.lastUpdate.getTime() > 40) {
            com.adapei.navhelper.Location.checkLocationPermission(this);
            Location currentLocation = Constants.locationEngine.getLastLocation();

            for(int i = 0; i < 100 && currentLocation == null; i++){
                currentLocation = Constants.locationEngine.getLastLocation();
            }

            double lat1 = currentLocation.getLatitude();
            double long1 = currentLocation.getLongitude();
            double lat2 = nextDirection.latitude();
            double long2 = nextDirection.longitude();

            double x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(long2 - long1);
            double y = Math.sin(long2 - long1) * Math.cos(lat2);

            double mAzimuth = 2 * Math.atan(y / (Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) + x));

            float[] adjustedRotationMatrix = new float[9];
            SensorManager.remapCoordinateSystem(rMat, SensorManager.AXIS_X, SensorManager.AXIS_Z, adjustedRotationMatrix);
            float[] orientationXZ = new float[3];
            SensorManager.getOrientation(adjustedRotationMatrix, orientationXZ);
            float[] orientation = new float[3];
            SensorManager.getOrientation(rMat, orientation);

            double mAzimuthDeg = Math.toDegrees(mAzimuth);
            double deviceAzimuthDeg = Math.toDegrees(orientation[0]);


            // Debug TextView
            TextView debug1 = findViewById(R.id.debug1);
            debug1.setText("destLat:Lng : " + lat2 + " : " + long2);

            TextView debug2 = findViewById(R.id.debug2);
            debug2.setText("posLat:Lng : " + currentLocation.getLatitude() + " : " + currentLocation.getLongitude());

            TextView debug3 = findViewById(R.id.debug3);
            debug3.setText("N°/tel : " + deviceAzimuthDeg);

            TextView debug4 = findViewById(R.id.debug4);
            debug4.setText("N°/dst : " + mAzimuthDeg);

            Location nextDirectionLocation = new Location("");
            nextDirectionLocation.setLatitude(lat2);
            nextDirectionLocation.setLongitude(long2);

            // Initial :    - mAzimuthDeg - deviceAzimuthDeg                                    orientationXZ[1] < 0
            // Crash :      (-currentLocation.bearingTo(nextDirectionLocation) + 360) % 360     orientationXZ[1] < 0
            this.setArrow((float) (-mAzimuthDeg - deviceAzimuthDeg), orientationXZ[1] < 0); // Inverted if screen face the bottom : orientationXZ[1] < 0
            this.lastUpdate = new Date();
        }
    }

    /**
     * Set the direction of the arrow given by a rotation and a possible inversion
     * @param rotation The rotation of the arrow
     * @param inverted True if the arrow has to be inverted
     */
    public void setArrow(float rotation, boolean inverted) { // mAzimuth en radian
        if (this.nextDirection == null)
            return;

        float invertedRotation = ((inverted ? -1 : 1) * rotation + 360) % 360; // normalize the rotation between 0 and 360

        int orange_range = 8;

        //Check if the new value of rotation is not too precise.
        if (Math.abs(this.arrow.getRotation() - invertedRotation) > 3) {
            //System.out.println(invertedRotation);
            this.arrow.setRotation(invertedRotation);
        }

        //control the color of the arrow. Depends of the atrribute DEGREE_ARROW
        if ((invertedRotation <= DEGREE_ARROW) || (invertedRotation >= 360-DEGREE_ARROW)) {
            setArrowColor(R.color.colorGreenArrow);
            if (!okPosition) {
                Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
                v.vibrate(200);
                okPosition = true;
            }
        } else if((invertedRotation <= (DEGREE_ARROW+orange_range)) || (invertedRotation >= 360-(DEGREE_ARROW+orange_range))) {
            //if the degree of the arrow is 5° more of the reference one, orange one
            setArrowColor(255,128,0);
        } else {
            setArrowColor(R.color.colorRedArrow);
            okPosition = false;
        }
    }

    /**
     * set the color of the arrow depends of rgb pigments
     * @param r red value <255
     * @param g green value <255
     * @param b blue value <255
     */
    private void setArrowColor(int r, int g, int b) {
        this.arrow.setColorFilter(Color.rgb(r,g,b));
    }

    /**
     * set the arrow color from a ressource color
     * @param color a color ressource file
     */
    private void setArrowColor(int color) { this.arrow.setColorFilter(getApplicationContext().getResources().getColor(color)); }

    /**
     * On click on the center of the arrow, refresh the ui
     * @param view
     */
    public void refreshButton(View view) {
        updateUI();
    }
}
